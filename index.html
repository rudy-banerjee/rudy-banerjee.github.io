<!DOCTYPE html>
<html>
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Parkinsans:wght@300..800&display=swap" rel="stylesheet">
</head>
<body>

  <h1>Rudy's Blog</h1>

  <h3>Wicked Problems</h3>
  <p>I don't know where I got put onto the idea of Wicked Problems, but somehow or another, I found myself on a website, looking at <a href="https://blog.codinghorror.com/development-is-inherently-wicked/">the following blog post</a>.</p>
  <p>Something here captured my attention.</p>

  <div>
    <blockquote>
      <p>As far as I'm concerned, all software development can be classified as a Wicked Problem. It's far too complex and far too annoyingly micro-complicated to allow for a whole lot of rational planning. I know from personal experience that I can never get very far without writing code to better understand the problem I am trying to solve.</p>
    </blockquote>
  </div>

  <p>
    Very interesting stuff. I read more into it, and found in <a href="https://increment.com/planning/software-development-as-a-wicked-problem/">an article</a> that Wicked Problems seemed to refer to a class of real-world project implementation complexity.
    I understood Wicked Problems as projects with such an undefined scope that you have to try programming them out to generate the requirements for what you are building.
    I talked about this idea with a few people at the UPL (Undergraduate Project Laboratory at the University of Wisconsin-Madison), and wasn't able to convince them that this was a particularly useful way of looking at projects.
  </p>
  
  <p>
    At the time, I had been working on various side projects, but was unsure about how to start tackling larger scoped projects, like building something like a YouTube clone or an NES emulator (someday I will write a blog post about this as well).
    The idea of wicked problems provided me with a convenient justification for starting more serious, larger-scoped projects without planning ahead at all.
    This outlook may have been a bit counter-productive at the time, because I had been "coding through the lifecycle of a project" before, when those were tutorials I was following on YouTube verbatim.
  </p>
  <p>
    At this point in time, I probably needed more experience examining and planning out the scope of larger projects, instead of just jumping in having zero plan, and getting bogged down by a larger scope and trickier details than I imagined.
    So if it's impossible to plan a project from scratch, so why bother planning at all?
    It's hard to dive head-first into something non-trivial without a clear plan, just being driven by a vague vision and hope.
    Especially in this environment where learning how to build intricate full-stack software projects isn't easy, and is something that CS students have to pick up on their own.
  </p>
  <p>
    But the idea of Wicked Problems makes more sense under a mentality where you plan and develop in smaller increments, allowing you to develop in a more agile way and completely re-implement parts of the project if necessary.
    It gave me the idea that straight coding and planning around uncertainties were two seperate but very connected aspects of building a project, both requiring different skills.
    It's a lot easier to mix planning/research and coding/bug fixing when you break down projects into modular pieces, and then working on that project from a specific direction to be able to demo your progress easily for better and easily-maintainable feedback loops over time.
  </p>
  
  <p>An example of this is the time I worked on an web-based NES emulator in JavaScript.</p>
  
  <p>
    Building a small game console emulator is remarkably hard to start, because it involves emulating the behavior of an entire computer through just code constructs.
    I had first heard about the idea of emulating a CPU in Java by just representing the CPU as a class that just decodes integer opcodes and does bit arithmetic on them, and representing memory as a large array of integers.
  </p>
  <p>
    So I started building the project from the CPU side with another guy (Lucas Scharenboch, a much more diligent guy than me). There were at least 50 opcodes, each involving consulting old CPU documentation, implementing fairly complicated bit arithmetic, and strenuously testing each opcode for weird bugs.
    In addition to the mountain of somewhat labor-intensive work for implementing the opcodes, we also had to figure out how the Picture Processing Unit worked, which was a sperarate piece of rendering hardware and required complex timing synchronization with the CPU.
    I got mired in the micro-complexities of different parts of the project, and then gave up. The original build plan I had come up with didn't do enough to keep my enthusiasim in the project alive.
  </p>
  <p>
    The second time around, after just not thinking about it for a year, I decided to build the emulator starting from the display screen, in such a way where I could view the evolution of the project through running programs through the CPU and seeing what it output on the display.
    It was easier beacuse I had previous development experience on this project and basic understandings of the complicated relationship between different components, and because I could plan development around those challenges.
  </p>
  <p>
    I started just an HTML canvas element, with a basic JS program to bounce a ball across the canvas at the resolution and pixel density of the original screen I was trying to emulate.
    I was then able to build better debugging tools around the idea of the display.
    Additionally, I just completely stopped writing unit tests and instead tested my code out using real videogame data and smaller assembly programs I had to manually write in CPU opcodes, which was a better idea.
    A much faster and more interesting feedback loop that allowed me to demo the progress of the emulator in an easily viewable way, and kept me anchored to the goal of the project throughout development whenever I ran into heavy enough micro-complexities to distract me from the overarching scope of the project.
  </p>
  
  <p>
    The idea of Wicked Problems makes more sense in the world of the early 2000's, when waterfall project management involving months of upfront design work and tail-end QA/testing was much more common in the industry, and Agile development was a much more fringe idea.
    It didn't end up being any sort of silver bullet as a strategy for getting projects done; you're still bounded by the amount of effort you put in and weird bugs you're willing to put up with.
    Additionally, I realized that even though the emulator project is difficult, it doesn't seem to come close to the scope of a Wicked Problem, which seems to refer more towards multi-year projects involving collaboration between teams of people.
    But it's a useful concept to keep in mind when tackling large-scale projects.
  </p>
  <p>
    An interesting idea to consider here is that Agile seemed to have emerge as a solution to tackling software projects that could be classified as Wicked Problems, which is a development process designed to achieve high speed iteration through fast feedback loops.
    If you start with the assumption that your goals and success criteria aren't super clear, and you need to develop in a manner that consistently prioritizes creating usable software, turns out your software will be usuable to a higher degree than designed otherwise.
  </p>

  <style>
    h1, h3, p {
      font-family: 'Parkinsans', sans-serif; 
    }

    div:has(> blockquote) {
      background-color: #ededed;
      margin: 10px auto;
      padding: 15px;
      border-radius: 5px;
    }
    
    blockquote p::before {
      content: '\201C';
    }
    
    blockquote p::after {
      content: '\201D';
    }
    
    blockquote + p {
      text-align: right;
    }
  </style>
  
</body>
</html> 
